package sort

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)

        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    i, j := low, high
    for i < j {
        for i < j && arr[j] >= arr[low] {
            j--
        }
        for i < j && arr[i] <= arr[low] {
            i++
        }
        arr[i], arr[j] = arr[j], arr[i]
    }
    arr[i], arr[low] = arr[low], arr[i]
    return i
}

func partition2(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

/**
这段代码是实现了快速排序（QuickSort）算法的一个版本。快速排序是一种非常有效的排序算法，它的基本思想是“分而治之”（Divide and Conquer）。

这里主要有两个函数：`partition2` 和 `quickSort2`。

1. `partition2` 函数的目的是进行一次分区操作。它接受一个数组和两个索引作为参数，一个是低索引 `low`，一个是高索引 `high`。
函数首先选择一个基准元素 `pivot`（这里选择的是 `high` 索引处的元素），然后将数组分为两个部分：
小于 `pivot` 的元素和大于或等于 `pivot` 的元素。这个函数返回的是 `pivot` 元素的最终位置。

   具体实现中，`i` 初始化为 `low - 1`，表示小于 `pivot` 的元素的最后一个位置。
然后遍历 `low` 到 `high-1` 的元素，如果某个元素小于 `pivot`，就将 `i` 加一，
然后交换 `i` 和当前元素的位置，这样就保证了 `i` 之前的元素都小于 `pivot`。
最后，交换 `i+1` 位置和 `high` 位置的元素，这样 `pivot` 就位于正确的位置，
即所有小于 `pivot` 的元素在其左侧，所有大于 `pivot` 的元素在其右侧。

2. `quickSort2` 函数是实现快速排序的主函数。它首先检查 `low` 是否小于 `high`，
如果不是，说明这个部分已经排序完成，直接返回。如果是，就先调用 `partition2` 函数进行分区，
然后递归地对 `pivot` 左边和右边的部分进行快速排序。

这个版本的快速排序是原地排序，也就是说，它不需要额外的存储空间，只需要在原数组上进行操作。
*/

/**
时间和空间复杂度分析：

注意 log n 的意思每次都能使得问题的规模减半

快速排序是一种使用分治策略的排序算法。它的基本思想是选择一个枢轴元素，将数组分为两部分，一部分包含所有小于枢轴的元素，另一部分包含所有大于或等于枢轴的元素，然后递归地对这两部分进行快速排序。

**时间复杂度：**

- 最好情况：如果每次都能均匀地划分数组，即每次选取的枢轴都能将数组划分为两个大致相等的部分，那么快速排序的时间复杂度为 (O(nlog n))。

- 最坏情况：如果每次选取的枢轴都是数组中的最小元素或最大元素，那么每次划分只能将数组的大小减少1，这样的话，快速排序的时间复杂度为 (O(n^2))。

- 平均情况：在平均情况下，快速排序的时间复杂度也是 (O(nlog n))。这是因为随机选取枢轴的期望时间复杂度为 (O(nlog n))，并且在实践中，快速排序通常比其他 (O(nlog n)) 的排序算法更快。

**空间复杂度：**

由于快速排序是递归的，需要使用栈来保存递归调用的信息。在最坏情况下，如果每次划分只能将数组的大小减少1，那么递归深度为 (n)，所以空间复杂度为 (O(n))。在最好情况下，如果每次都能均匀地划分数组，那么递归深度为 (log n)，所以空间复杂度为 (O(log n))。在平均情况下，空间复杂度也是 (O(log n))。

需要注意的是，虽然快速排序的最坏情况时间复杂度为 (O(n^2))，但是这种情况在实践中很少发生，而且可以通过一些策略（例如随机选取枢轴）来避免。因此，快速排序在实践中是一种非常有效的排序算法。
*/

/**
关于 log 和 lg
在不同的学科和地区，对数的表示方式可能会有所不同。以下是两种常见的表示方式：

1. 在计算机科学中，(log) 通常表示以2为底的对数，也就是 (log_2)。这是因为计算机科学中的许多概念，如二叉树的高度、二进制表示等，都与2有关。

2. 在数学和物理等科学中，(log) 通常表示以10为底的对数，也就是 (log_{10})。这是因为我们的计数系统是十进制的。

然而，这并不是硬性规定，具体表示方式可能会因上下文和习惯而异。在某些情况下，(log) 可能表示自然对数，即以数学常数 (e)（约等于2.71828）为底的对数。

至于 "lg"，在计算机科学和工程中，它通常表示以2为底的对数。然而，这同样并不是硬性规定，具体表示方式可能会因上下文和习惯而异。

总的来说，如果没有明确指定，那么 (log) 和 "lg" 的底数可能是2、10或 (e)，具体取决于上下文。如果需要明确，应该使用下标来表示底数，如 (log_2)、(log_{10}) 或 (log_e)。
*/

func quickSort2(arr []int, low, high int) {
    if low < high {
        pi := partition2(arr, low, high)
        quickSort2(arr, low, pi-1)
        quickSort2(arr, pi+1, high)
    }
}
